from MVVM.notified_property import NotifiedProperty
import tkinter as tki
import time


class View(tki.Canvas):
    """
    base class for view pages
    """
    __binded = {}
    __animated = {}
    __animated_timer = None
    tk: tki.Tk = None
    __views = {}

    HEIGHT = 600
    WIDTH = 800
    SECONDS = 180

    def __init__(self, parent: tki.Tk):
        """
        initializes new View.
        """
        super().__init__(parent)
        self._parent = parent
        self._bindings = []

    # region animation easing functions
    @staticmethod
    def linear(x):
        return x

    @staticmethod
    def square(x):
        return x * x
    # endregion

    @staticmethod
    def color(r, g, b):
        """
        returns string color from given RGB values
        """
        return "#%02x%02x%02x" % (r, g, b)

    # region navigation
    @staticmethod
    def add_view(view_mode_type, view_type):
        """
        registers the given view type for the given view mode type.
        """
        View.__views[view_mode_type] = view_type

    def _navigate(self, view_model):
        """
        navigates the view to the given view model.
        the view generated by the type of the viewmodel,
        from registered views types.
        """
        view_type = self.__views[type(view_model)]
        view = view_type(View.tk, view_model)

        def navigate2():
            self.pack_forget()
            view.pack(fill=tki.BOTH, expand=True)
            view._navigate_in()
            View.tk.update()
        View.tk.after(self._navigate_out(), navigate2)

    def _navigate_in(self):
        """
        protected method for applying animations and other things when
        navigated to the view. returns time of navigation in animations
        in ms.
        """
        return 0

    def _navigate_out(self):
        """
        protected method for applying animations and other things when
        navigated from the view. returns time of navigation out animations
        in ms.
        """
        for setter in self._bindings:
            self._unbinding(setter)
        return 0
    # endregion

    # region binding
    @staticmethod
    def __binding(setter, notified_property: NotifiedProperty):
        """
        binds the given setter to the given notified property.
        """
        if setter in View.__binded:
            View._unbinding(setter)

        def observer(): return View.__update(setter)
        View.__binded[setter] = notified_property, observer
        notified_property.add_observer(observer)
        View.__update(setter)

    def _binding(self, setter, notified_property: NotifiedProperty):
        """
        binds the given setter to the given notified property.
        """
        self._bindings.append(setter)
        View.__binding(setter, notified_property)

    @staticmethod
    def __unbinding(setter):
        """
        unbinding the given setter from the given notified property.
        """
        try:
            notified_property, observer = View.__binded[setter]
            notified_property.remove_observer(observer)
            del View.__binded[setter]
        except KeyError:
            pass

    def _unbinding(self, setter):
        """
        unbinding the given setter from the given notified property.
        """
        self._bindings.remove(setter)
        View.__unbinding(setter)

    @staticmethod
    def __update(setter):
        """
        updates the given setter.
        """
        notified_property, _ = View.__binded[setter]
        setter(notified_property.get())
    # endregion

    # region animation
    @staticmethod
    def _animate(setter, _from, to, duration, _type="int", easing=None, delay=0.0):
        """
        animates the given setter from the given _from to the given to.
        :param setter: function to set the value of the animated property
        :param _from: starting value of the animated property
        :param to: ending value of the animated property
        :param duration: duration of the animation in seconds
        :param _type: type of the animated property ('int', 'float', 'ints' or 'floats')
        :param easing: easing function to apply to the animation
        :param delay: delay of the animation in seconds
        """
        if isinstance(_from, float):
            _type = "float"
        elif isinstance(_from, tuple):
            if isinstance(_from[0], int):
                _type = "ints"
            elif isinstance(_from[0], float):
                _type = "floats"

        if easing is None:
            easing = View.linear

        if setter in View.__animated:
            del View.__animated[setter]
        View.__animated[setter] = (_type, _from, to, duration,
                                   easing, time.time() + delay)
        if View.__animated_timer is None:
            View.__animated_timer = View.tk.after(5, View.__update_animations)

    @staticmethod
    def __update_animations():
        """
        updates the registered animations.
        """
        remove = []
        for setter in list(View.__animated.keys()):
            _type, _from, to, duration, easing, start_time = View.__animated[setter]
            # delay
            if time.time() < start_time:
                continue
            # check finish
            if time.time() - start_time > duration:
                remove.append(setter)
                x = 1
            else:
                x = (time.time() - start_time) / duration
            x = easing(x)
            # set value
            if _type == "float":
                setter(_from + (to - _from) * x)
            elif _type == "int":
                setter(round(_from + (to - _from) * x))
            elif _type == "ints":
                res = []
                for i in range(len(_from)):
                    res.append(round(_from[i] + (to[i] - _from[i]) * x))
                setter(*res)
            elif _type == "floats":
                res = []
                for i in range(len(_from)):
                    res.append(_from[i] + (to[i] - _from[i]) * x)
                setter(*res)
        # remove finished animations
        for key in remove:
            del View.__animated[key]
        # call again if there are still animations
        if len(View.__animated) == 0:
            View.tk.after_cancel(View.__animated_timer)
            View.__animated_timer = None
        else:
            View.tk.after(5, View.__update_animations)
    # endregion
